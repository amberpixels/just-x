#!/usr/bin/env bash
set -euo pipefail

VERSION="0.1.0"

# Generates a shell function (+ noglob alias) that wraps `just` with character translation.
# The generated function is meant to be eval'd in the user's shell rc file.
cmd_init() {
  local name="${1:-just}"
  cat <<EOF
_just_x_${name}() {
  local cmd="\${1:-}"

  # Intercept --list/-l/--summary and reverse-translate output
  for arg in "\$@"; do
    case "\$arg" in
      --list|-l|--summary)
        just-x list "\$@"
        return
        ;;
    esac
  done

  if [[ -z "\$cmd" || "\$cmd" != *['!?:']* ]]; then
    command just "\$@"
    return
  fi
  shift
  cmd="\${cmd//\!/\${JUST_X_BANG:--x}}"
  cmd="\${cmd//\?/\${JUST_X_QUESTION:--q}}"
  cmd="\${cmd//\:/\${JUST_X_COLON:---}}"
  command just "\$cmd" "\$@"
}
alias ${name}='noglob _just_x_${name}'
EOF
}

# Prints help text with usage examples and configuration options.
usage() {
  cat <<'EOF'
just-x — Extended recipe names for just

Usage:
  just-x init [name]         Generate shell function (default name: just)
  just-x translate <recipe>  Show how a recipe name gets translated
  just-x version             Print version
  just-x help                Show this help

Setup (add to ~/.zshrc or ~/.bashrc):
  eval "$(just-x init)"

Examples:
  just dev!          → just dev-x
  just ready?        → just ready-q
  just app:build     → just app--build

Configuration (env vars):
  JUST_X_BANG="-x"       # ! replacement (default: -x)
  JUST_X_QUESTION="-q"   # ? replacement (default: -q)
  JUST_X_COLON="--"      # : replacement (default: --)
EOF
}

# Shows how a recipe name gets translated (e.g. "dev!" → "dev-x").
translate() {
  local recipe="${1:?Usage: just-x translate <recipe>}"
  local result="$recipe"
  result="${result//\!/${JUST_X_BANG:--x}}"
  result="${result//\?/${JUST_X_QUESTION:--q}}"
  result="${result//\:/${JUST_X_COLON:---}}"
  echo "${recipe} → ${result}"
}

# Runs `just --list` and reverse-translates recipe names back to friendly syntax.
# Preserves ANSI colors and adjusts comment alignment after replacements.
cmd_list() {
  local bang="${JUST_X_BANG:--x}"
  local question="${JUST_X_QUESTION:--q}"
  local colon="${JUST_X_COLON:---}"

  command just --color always "$@" | awk \
    -v bang="$bang" \
    -v question="$question" \
    -v colon="$colon" \
    '
    function replace(str, pat, rep,    result, idx) {
      result = ""
      while ((idx = index(str, pat)) > 0) {
        result = result substr(str, 1, idx - 1) rep
        str = substr(str, idx + length(pat))
      }
      return result str
    }
    function count_of(str, pat,    n, idx) {
      n = 0
      while ((idx = index(str, pat)) > 0) {
        n++
        str = substr(str, idx + length(pat))
      }
      return n
    }
    {
      line = $0

      # Strip ANSI to find comment position and count replacements
      clean = line
      gsub(/\033\[[0-9;]*m/, "", clean)

      extra = 0
      if (match(clean, / +# /)) {
        left_clean = substr(clean, 1, RSTART - 1)
        extra += count_of(left_clean, colon) * (length(colon) - 1)
        extra += count_of(left_clean, bang) * (length(bang) - 1)
        extra += count_of(left_clean, question) * (length(question) - 1)
      }

      # Do replacements on the full colored line
      line = replace(line, bang, "!")
      line = replace(line, question, "?")
      line = replace(line, colon, ":")

      # Add compensating spaces before the comment marker
      if (extra > 0) {
        pad = ""
        for (i = 0; i < extra; i++) pad = pad " "
        # Insert before ANSI-coded # or plain #
        if (!sub(/\033\[[0-9;]*m#/, pad "&", line)) {
          sub(/#/, pad "#", line)
        }
      }

      print line
    }
    '
}

case "${1:-help}" in
  init)      shift; cmd_init "$@" ;;
  list)      shift; cmd_list "$@" ;;
  translate) shift; translate "$@" ;;
  version)   echo "just-x $VERSION" ;;
  help|--help|-h) usage ;;
  *)         echo "Unknown command: $1" >&2; usage >&2; exit 1 ;;
esac
